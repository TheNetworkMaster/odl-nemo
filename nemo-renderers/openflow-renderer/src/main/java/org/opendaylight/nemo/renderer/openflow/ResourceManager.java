/* * Copyright (c) 2015 Huawei, Inc. and others. All rights reserved. * * This program and the accompanying materials are made available under the * terms of the Eclipse Public License v1.0 which accompanies this distribution, * and is available at http://www.eclipse.org/legal/epl-v10.html */package org.opendaylight.nemo.renderer.openflow;import org.opendaylight.controller.md.sal.binding.api.DataBroker;import org.opendaylight.controller.md.sal.binding.api.WriteTransaction;import org.opendaylight.controller.md.sal.common.api.data.LogicalDatastoreType;import org.opendaylight.yangtools.yang.binding.InstanceIdentifier;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.google.common.util.concurrent.FutureCallback;import com.google.common.util.concurrent.Futures;import com.google.common.collect.HashBasedTable;import com.google.common.collect.Table;import java.util.*;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import com.google.common.util.concurrent.CheckedFuture;import org.opendaylight.yangtools.yang.binding.InstanceIdentifier;import org.opendaylight.controller.md.sal.common.api.data.TransactionCommitFailedException;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;import java.io.BufferedReader;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;import  java.lang.*;import org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.inet.types.rev100924.IpAddress;import org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.inet.types.rev100924.Ipv4Address;import org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.yang.types.rev100924.MacAddress;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.PhysicalNetworkBuilder;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.PhysicalNetwork;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.PhysicalNodeInstance;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.PhysicalPortInstance;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.attribute.instance.AttributeValue;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.attribute.instance.AttributeValueBuilder;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.network.physical.nodes.PhysicalNode;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.network.physical.nodes.PhysicalNodeBuilder;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.network.physical.nodes.PhysicalNodeKey;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.network.physical.links.PhysicalLink;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.network.physical.links.PhysicalLinkBuilder;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.network.physical.links.PhysicalLinkKey;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.node.instance.PhysicalPort;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.node.instance.PhysicalPortBuilder;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.node.instance.PhysicalPortKey;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.port.instance.Attribute;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.port.instance.AttributeBuilder;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.port.instance.AttributeKey;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.nemo.engine.common.rev151010.AttributeName;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.nemo.engine.common.rev151010.PhysicalNodeId;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.nemo.engine.common.rev151010.PhysicalPortId;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.nemo.engine.common.rev151010.PhysicalLinkId;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.nemo.engine.common.rev151010.PhysicalHostId;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.nemo.engine.common.rev151010.PhysicalHostName;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.network.physical.hosts.PhysicalHostBuilder;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.network.physical.hosts.PhysicalHostKey;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.network.physical.hosts.PhysicalHost;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.host.instance.IpAddresses;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.host.instance.IpAddressesBuilder;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.network.PhysicalNodes;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.network.PhysicalLinks;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.network.PhysicalHosts;import org.opendaylight.nemo.renderer.openflow.entity.ResourceBean;public class ResourceManager implements AutoCloseable {        private static final Logger LOG = LoggerFactory.getLogger(ResourceManager.class);    public final static String PROPERTY_FILE_PATH = "etc/nemo/nemo-openflow-renderer-resource.json";    final private DataBroker dataProvider;    private ObjectMapper objectMapper = null;    private Table<PhysicalNodeId, PhysicalPortId, MacAddress> externalNetworkMacTable;    public ResourceManager(DataBroker dataProvider){            this.dataProvider = dataProvider;        this.objectMapper = new ObjectMapper();        this.externalNetworkMacTable = HashBasedTable.create();        String resourceInfo = ReadFile(PROPERTY_FILE_PATH);        buildPhysicalNetworkFromConfig(resourceInfo);        LOG.info("nemo:Initialized resource manager for Openflow renderer.");    }    public Table<PhysicalNodeId, PhysicalPortId, MacAddress> getExternalNetworkMacTable(){        return  this.externalNetworkMacTable;    }    private void buildPhysicalNetworkFromConfig(String resource) {        try {            PhysicalNetworkBuilder phyNetwrokBuilder= new PhysicalNetworkBuilder();            PhysicalNodeBuilder phyNodeBuilder = new PhysicalNodeBuilder();            JsonNode rootNode = objectMapper.readTree(resource);            JsonNode pn = rootNode.path("physicalnetwork");            JsonNode nodes = pn.path("node");            JsonNode links = pn.path("link");            JsonNode hosts = pn.path("host");            LOG.debug("Import physical nodes into DataStore.");            for(int i = 0; i< nodes.size(); i++){                LOG.debug("build physical node execution body");                //JsonNode node = nodeIt.next();                JsonNode node = nodes.get(i);                JsonNode ports = node.path("port");                PhysicalNodeBuilder nodeBuilder = new PhysicalNodeBuilder();                nodeBuilder.setNodeId(new PhysicalNodeId(node.get("node-id").asText()));                PhysicalNodeKey key = new PhysicalNodeKey(nodeBuilder.getNodeId());                nodeBuilder.setKey(key);                String nodetype = node.get("node-type").asText();                if((!(nodetype.equals("switch"))) && (!(nodetype.equals("router")))){                    continue;                }                if(nodetype.equals("switch"))                {                    nodeBuilder.setNodeType(PhysicalNodeInstance.NodeType.Switch);                }else if(nodetype.equals("router")){                    nodeBuilder.setNodeType(PhysicalNodeInstance.NodeType.Router);                }                List<PhysicalPort> phyPortList = new ArrayList<PhysicalPort>();                //for (Iterator<JsonNode> portIt = ports.elements(); portIt.hasNext(); ) {                for(int j =0; j < ports.size(); j++){                    LOG.debug("build physical port execution body");                    //JsonNode port = portIt.next();                    JsonNode port = ports.get(j);                    PhysicalPortBuilder phyPortbuilder =  new PhysicalPortBuilder();                    phyPortbuilder.setPortId(new PhysicalPortId(port.get("port-id").asText()));                    if((port.get("port-type").asText()).equals("external")) {                        phyPortbuilder.setPortType(PhysicalPortInstance.PortType.External);                    }                    else {                        phyPortbuilder.setPortType(PhysicalPortInstance.PortType.Internal);                    }                    //add mac-address for each port                    LOG.info("nemo:j=" + j);                    MacAddress mac = new MacAddress(port.get("port-mac-address").asText());                    phyPortbuilder.setMacAddress(mac);                    phyPortbuilder.setBandwidth((long) (port.get("bandwidth").asInt()));                    JsonNode attrs = port.path("attribute");                    List<Attribute> AttrList = new ArrayList<Attribute>();                    for(int r = 0; r < attrs.size(); r++){                        LOG.debug("build physical port attribute execution body.");                        JsonNode portattr = attrs.get(r);                        AttributeBuilder  attrbuilder = new AttributeBuilder();                        attrbuilder.setAttributeName(new AttributeName(portattr.path("name").asText()));                        AttributeValueBuilder avbd = new AttributeValueBuilder();                        avbd.setStringValue(portattr.path("value").asText());                        attrbuilder.setKey(new AttributeKey(attrbuilder.getAttributeName()));                        attrbuilder.setAttributeValue(avbd.build());                        Attribute attr_instance = attrbuilder.build();                        AttrList.add(attr_instance);                    }                    /*                    Iterator<String> keys = attrs.fieldNames();                    while(keys.hasNext()) {                        LOG.info("build physical port attribute execution body.");                        String fieldName = keys.next();                        attrbuilder.setAttributeName(new AttributeName(fieldName));                        AttributeValueBuilder avbd = new AttributeValueBuilder();                        avbd.setStringValue(attrs.path(fieldName).asText());                        attrbuilder.setKey(new AttributeKey(attrbuilder.getAttributeName()));                        attrbuilder.setAttributeValue(avbd.build());                        Attribute attr_instance = attrbuilder.build();                        AttrList.add(attr_instance);                    }                    */                    phyPortbuilder.setAttribute(AttrList);                    phyPortList.add(phyPortbuilder.build());                }                nodeBuilder.setPhysicalPort(phyPortList);                /*node attribute list*/                JsonNode node_attrs = node.path("attribute");                List<org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.node.instance.Attribute>                        node_AttrList = new ArrayList<org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.node.instance.Attribute>();                for(int t = 0; t < node_attrs.size(); t++){                    LOG.debug("build physical node attribute execution body.");                    JsonNode node_attr = node_attrs.get(t);                    org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.node.instance.AttributeBuilder                            attrbuilder = new org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.node.instance.AttributeBuilder();                    attrbuilder.setAttributeName(new AttributeName(node_attr.path("name").asText()));                    AttributeValueBuilder avbd = new AttributeValueBuilder();                    avbd.setStringValue(node_attr.path("value").asText());                    attrbuilder.setKey(new org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.node.instance.AttributeKey(attrbuilder.getAttributeName()));                    attrbuilder.setAttributeValue(avbd.build());                    org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.node.instance.Attribute node_attr_instance = attrbuilder.build();                    node_AttrList.add(node_attr_instance);                }                nodeBuilder.setAttribute((List<org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.generic.physical.network.rev151010.physical.node.instance.Attribute>) node_AttrList);                PhysicalNode phyNode = nodeBuilder.build();                //phyNodeList.add(phyNode);                LOG.debug("Ready to write node to data store.");                try {                    WriteTransaction t = dataProvider.newWriteOnlyTransaction();                    InstanceIdentifier<PhysicalNode> phynode_iid = InstanceIdentifier                            .builder(PhysicalNetwork.class)                            .child(PhysicalNodes.class)                            .child(PhysicalNode.class, key)                            .build();                    t.put(LogicalDatastoreType.OPERATIONAL, phynode_iid, phyNode, true);                    CheckedFuture<Void, TransactionCommitFailedException> f = t.submit();                    Futures.addCallback(f, new FutureCallback<Void>() {                        @Override                        public void onFailure(Throwable t) {                            System.out.println("write transaction onFailure.");                            LOG.error("Could not write PhysicalNode", t);                        }                        @Override                        public void onSuccess(Void result) {                            //System.out.println("write transaction onSuccess.");                            LOG.debug("write transaction onSuccess.");                        }                    });                } catch (Exception e) {                    e.printStackTrace();                }            }            LOG.debug("Import physical links into DataStore.");            for(int m = 0; m< links.size(); m++){                LOG.debug("build physical link execution body");                JsonNode link = links.get(m);                String strLeftNodeId = link.get("left-node-id").asText();                String strRightNodeId = link.get("right-node-id").asText();                if(strLeftNodeId.contains("external")||strRightNodeId.contains("external")){                    String strExternalNodeId = "";                    PhysicalNodeId accessNodeId = null;                    PhysicalPortId accessPortId = null;                    if(strLeftNodeId.contains("external")){                        strExternalNodeId = strLeftNodeId;                        accessNodeId = new PhysicalNodeId(link.get("right-node-id").asText());                        accessPortId = new PhysicalPortId(link.get("right-port-id").asText());                    }else{                        strExternalNodeId = strRightNodeId;                        accessNodeId = new PhysicalNodeId(link.get("left-node-id").asText());                        accessPortId = new PhysicalPortId(link.get("left-port-id").asText());                    }                    for(int b = 0; b < nodes.size(); b++){                        JsonNode pnode = nodes.get(b);                        if(strExternalNodeId.equals(pnode.get("node-id").asText())){                            MacAddress macAddress = new MacAddress(pnode.get("mac-address").asText());                            this.externalNetworkMacTable.put(accessNodeId, accessPortId, macAddress);                            break;                        }                    }                    continue;                }                PhysicalLinkBuilder linkBuilder = new PhysicalLinkBuilder();                PhysicalLinkId phylinkid = new PhysicalLinkId(link.get("link-id").asText());                linkBuilder.setLinkId(phylinkid);                linkBuilder.setSrcNodeId(new PhysicalNodeId(link.get("left-node-id").asText()));                linkBuilder.setSrcPortId(new PhysicalPortId(link.get("left-port-id").asText()));                linkBuilder.setDestNodeId(new PhysicalNodeId(link.get("right-node-id").asText()));                linkBuilder.setDestPortId(new PhysicalPortId(link.get("right-port-id").asText()));                linkBuilder.setBandwidth((long) (link.get("link-bandwidth").asLong()));                linkBuilder.setDelay((long) (link.get("delay").asLong()));                linkBuilder.setMetric((long) (link.get("metric").asLong()));                linkBuilder.setLossRate((short) (link.get("delay").asInt()));                PhysicalLink  phyLink = linkBuilder.build();                LOG.debug("Ready to write link to data store.");                try {                    WriteTransaction t = dataProvider.newWriteOnlyTransaction();                    InstanceIdentifier<PhysicalLink> phylink_iid = InstanceIdentifier                            .builder(PhysicalNetwork.class)                            .child(PhysicalLinks.class)                            .child(PhysicalLink.class, new PhysicalLinkKey(linkBuilder.getLinkId()))                            .build();                    t.put(LogicalDatastoreType.OPERATIONAL, phylink_iid, phyLink, true);                    CheckedFuture<Void, TransactionCommitFailedException> f = t.submit();                    Futures.addCallback(f, new FutureCallback<Void>() {                        @Override                        public void onFailure(Throwable t) {                            System.out.println("write transaction onFailure.");                            LOG.error("Could not write PhysicalLink", t);                        }                        @Override                        public void onSuccess(Void result) {                            //System.out.println("write transaction onSuccess.");                            LOG.debug("write transaction onSuccess.");                        }                    });                } catch (Exception e) {                    e.printStackTrace();                }            }            LOG.debug("Import hosts into DataStore.");            for(int n = 0; n< hosts.size(); n++){                LOG.debug("build host execution body");                JsonNode host = hosts.get(n);                PhysicalHostBuilder  hostBuilder = new PhysicalHostBuilder();                hostBuilder.setHostId(new PhysicalHostId(host.get("id").asText()));                hostBuilder.setKey(new PhysicalHostKey(hostBuilder.getHostId()));                hostBuilder.setHostName(new PhysicalHostName(host.get("name").asText()));                IpAddressesBuilder IpAddrBuilder = new IpAddressesBuilder();                List<IpAddress> ipList = new ArrayList<IpAddress>();                JsonNode ipaddrs = host.path("ip-addresses");                for(int p = 0 ; p < ipaddrs.size(); p++){                    JsonNode ipaddr = ipaddrs.get(p);                    IpAddress ip = new IpAddress(new Ipv4Address(ipaddr.get("ip-address").asText()));                    ipList.add(ip);                }                IpAddrBuilder.setIpAddress(ipList);                hostBuilder.setIpAddresses(IpAddrBuilder.build());                MacAddress mac = new MacAddress(host.get("mac-address").asText());                hostBuilder.setMacAddress(mac);                hostBuilder.setNodeId(new PhysicalNodeId(host.get("node-id").asText()));                hostBuilder.setPortId(new PhysicalPortId(host.get("connector-id").asText()));                PhysicalHost phyHost = hostBuilder.build();                LOG.debug("Ready to write host to data store.");                try {                    WriteTransaction t = dataProvider.newWriteOnlyTransaction();                    InstanceIdentifier<PhysicalHost> phyhost_iid = InstanceIdentifier                            .builder(PhysicalNetwork.class)                            .child(PhysicalHosts.class)                            .child(PhysicalHost.class, new PhysicalHostKey(hostBuilder.getHostId()))                            .build();                    t.put(LogicalDatastoreType.OPERATIONAL, phyhost_iid, phyHost, true);                    CheckedFuture<Void, TransactionCommitFailedException> f = t.submit();                    Futures.addCallback(f, new FutureCallback<Void>() {                        @Override                        public void onFailure(Throwable t) {                            System.out.println("write transaction onFailure.");                            LOG.error("Could not write PhysicalHost", t);                        }                        @Override                        public void onSuccess(Void result) {                            //System.out.println("write transaction onSuccess.");                            LOG.debug("write transaction onSuccess.");                        }                    });                } catch (Exception e) {                    e.printStackTrace();                }            }        } catch (JsonProcessingException e) {            e.printStackTrace();        } catch(IOException e){            e.printStackTrace();        }        LOG.debug("buildPhysicalNetworkFromConfig end.");        System.out.print("Loading physical network configuration has been completed.");    }    private String ReadFile(String Path){        BufferedReader reader = null;        String laststr = "";        try{            FileInputStream fileInputStream = new FileInputStream(Path);            InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, "UTF-8");            reader = new BufferedReader(inputStreamReader);            String tempString = null;            while((tempString = reader.readLine()) != null){                laststr += tempString;            }            reader.close();        }catch(IOException e){            e.printStackTrace();        }finally{            if(reader != null){                try {                    reader.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }        return laststr;    }    @Override    public void close() throws Exception {    }}